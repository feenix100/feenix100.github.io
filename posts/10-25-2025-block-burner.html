<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Block Burner the game</title>
  <style>
    main { scroll-snap-type: y proximity; }
    #story.story-block {
      height: auto;             /* not hard-locked to viewport */
      min-height: 100vh;        /* still fills first view */
      overflow: visible;        /* allow normal page scroll */
    }

    :root{--bg:#0b0f14;--fg:#e6edf3;--line:#1f2833}
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; }
    #site-header { position: sticky; top: 0; z-index: 10; backdrop-filter: blur(6px); background: color-mix(in srgb, var(--bg) 85%, transparent); border-bottom: 1px solid var(--line); padding: 14px 20px; }
    #site-header h1 { margin: 0; font-size: 20px; letter-spacing: .3px; }

    .block { min-height: 85vh; display: flex; align-items: stretch; border-bottom: 1px solid var(--line); }

    .layout { flex: 1; display: flex; }
    .scene { flex: 1; position: relative; }
    .panel { width: min(360px, 32vw); padding: 24px 20px; border-left: 1px solid var(--line); background: linear-gradient(180deg, var(--bg) 0%, #0b0f14cc 70%, #0b0f1480 100%); display: flex; flex-direction: column; justify-content: center; gap: 12px; align-items: flex-start; }
    .panel .tag { font-weight: 700; font-size: 24px; line-height: 1.2; letter-spacing: .2px; }
    .panel p { margin: 0; font-size: 14px; line-height: 1.5; opacity: .9; letter-spacing: .2px; }
    .btn { appearance: none; border: 1px solid var(--line); background: #11161c; color: var(--fg); padding: 10px 14px; border-radius: 10px; cursor: pointer; transition: transform .05s ease, box-shadow .2s ease, background .2s ease; }
    .btn:hover { background:#121a22; }
    .btn:active { transform: translateY(1px); }

    .hint { position: fixed; left: 12px; bottom: 12px; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; opacity: .8; }
    .hint kbd { background: #11161c; border: 1px solid var(--line); padding: 2px 5px; border-radius: 4px; }

    .subsection-title {
      margin: 6px 0 8px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .2px;
    }

  
    /* Desert background canvas */
    #desert-bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      display: block;
    }
    /* Lift content above canvas */
    body > * { position: relative; z-index: 1; }
    /* Slightly stronger panel bg for readability */
    .panel { background: linear-gradient(180deg, color-mix(in srgb, var(--bg) 75%, #000 0%) 0%, #0b0f14dd 70%, #0b0f14b0 100%); }

/* Hide the parallax layers entirely */
#story .story-parallax {
  display: block !important;
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
}

#story.story-block {
  height: auto;
  min-height: 100vh;   /* fills first viewport, then flows */
  overflow: visible;
}
#story .story-scroll {
  height: auto;
  overflow: visible;
  scroll-snap-type: none;
  scroll-behavior: auto;
  padding-block: 24px;
}
#story .story-slide {
  min-height: auto;
  opacity: 1;
  transform: none;
  transition: none;
  padding: 24px 0;
}

/* If you kept this earlier, neutralize any page-level snap: */
#story.story-block { scroll-snap-align: none !important; }

    /* Full-viewport scrollytelling */
.story-block {
  position: relative;
  height: 100vh;
  width: 100%;
  padding: 0;
  margin: 0;
  overflow: hidden; /* background stays pinned */
}

/* Parallax background container */
.story-parallax {
  position: absolute;
  inset: 0;
  pointer-events: none;
  overflow: hidden;
  perspective: 800px; /* depth for parallax */
}

/* Generic parallax layer */
.story-parallax .layer {
  position: absolute;
  inset: -5vh -5vw; /* bleed edges so no gaps */
  transform: translateZ(0);
  will-change: transform, filter, opacity, background-position;
}

/* Stars: two fields moving at slightly different speeds */
.layer-stars,
.layer-stars-2 {
  background-image:
    radial-gradient(2px 2px at 20% 30%, rgba(255,255,255,.9), rgba(255,255,255,0)),
    radial-gradient(1.5px 1.5px at 70% 60%, rgba(255,255,255,.8), rgba(255,255,255,0)),
    radial-gradient(1.2px 1.2px at 40% 80%, rgba(255,255,255,.6), rgba(255,255,255,0)),
    radial-gradient(1px 1px at 85% 20%, rgba(255,255,255,.7), rgba(255,255,255,0));
  background-size: 600px 600px, 800px 800px, 700px 700px, 900px 900px;
  background-repeat: repeat;
  filter: drop-shadow(0 0 2px rgba(255,255,255,.35));
  animation: twinkle 8s linear infinite;
}
.layer-stars-2 {
  opacity: .7;
  filter: drop-shadow(0 0 3px rgba(255,255,255,.25));
  animation-duration: 12s;
}

/* Nebula haze */
.layer-nebula {
  background:
    radial-gradient(60% 60% at 20% 30%, rgba(122, 80, 255, .20), transparent 60%),
    radial-gradient(40% 40% at 70% 60%, rgba(255, 80, 180, .16), transparent 60%),
    radial-gradient(50% 50% at 45% 75%, rgba(80, 200, 255, .12), transparent 60%);
  filter: blur(12px) saturate(120%);
  mix-blend-mode: screen;
}

/* Milky Way band */
.layer-milky {
  background:
    linear-gradient(95deg, transparent 0 32%, rgba(255,255,255,.08) 40%, rgba(255,255,255,.18) 50%, rgba(255,255,255,.08) 60%, transparent 68%),
    radial-gradient(100% 60% at 50% 50%, rgba(255,255,255,.06), transparent 60%);
  transform: rotate(8deg) translateZ(-120px) scale(1.2);
  filter: blur(1.5px);
  opacity: .6;
}

/* Scroll container with snap */
.story-scroll {
  position: relative;
  height: 100%;
  width: min(980px, 92vw);
  margin: 0 auto;
  overflow-y: auto;           /* content scrolls */
  scroll-snap-type: y mandatory;
  scroll-behavior: smooth;
  padding-block: 4vh 8vh;     /* top/bottom padding */
  z-index: 1;                 /* above parallax */
}

/* Each slide fills viewport height for dramatic paging */
.story-slide {
  min-height: 100vh;
  scroll-snap-align: start;
  display: grid;
  align-content: center;
  gap: 14px;
  padding: 10vh 0;            /* breathing room */
  font-size: 18px;
  line-height: 1.65;
  backdrop-filter: blur(1px) saturate(105%);
  color: #e8ecff;
}

/* Headings */
.subsection-title {
  margin: 0 0 6px;
  font-size: 22px;
  font-weight: 800;
  letter-spacing: .3px;
  text-transform: none;
}

/* Subtle slide-in on view */
.story-slide {
  opacity: 0;
  transform: translateY(24px);
  transition: opacity .6s ease, transform .6s ease;
}
.story-slide.is-visible {
  opacity: 1;
  transform: translateY(0);
}

/* Controls */
.story-controls {
  margin-top: 24px;
}

/* Twinkle + slow parallax drift (CSS-only) */
@keyframes twinkle {
  from { background-position: 0 0, 0 0, 0 0, 0 0; }
  to   { background-position: 600px 400px, -800px 600px, 700px 500px, -900px 700px; }
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  .story-scroll { scroll-behavior: auto; }
  .layer-stars, .layer-stars-2 { animation: none; }
}




</style>
</head>
<body>
  <canvas id="desert-bg"></canvas>
  <a id="top"></a>

  <header id="site-header"><h1>Powerups: Block Burner</h1></header>

  <section id="block1" class="block">
    <div class="layout">
      <div class="scene" data-block="1" data-img="/blockburner/def/defB.png"></div>
      <aside class="panel">
        <div class="tag">“Bottom Sweep”</div>
        <p>Defensive - Clears your bottom row</p>
        <button class="btn" data-target="#block2">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block2" class="block">
    <div class="layout">
      <div class="scene" data-block="2" data-img="/blockburner/def/defU.png"></div>
      <aside class="panel">
        <div class="tag">“Chroma Wipe”</div>
        <p>Defensive - Clears all blocks of one random color
</p>
        <button class="btn" data-target="#block3">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block3" class="block">
    <div class="layout">
      <div class="scene" data-block="3" data-img="/blockburner/def/defRyellow.png"></div>
      <aside class="panel">
        <div class="tag">“Midas Touch”</div>
        <p>Defensive - Spawns a Midas block</p>
        <button class="btn" data-target="#block4">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block4" class="block">
    <div class="layout">
      <div class="scene" data-block="4" data-img="/blockburner/def/defN.png"></div>
      <aside class="panel">
        <div class="tag">“Color Burst”</div>
        <p>Defensive - Spawns a same-color cluster</p>
        <button class="btn" data-target="#block5">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block5" class="block">
    <div class="layout">
      <div class="scene" data-block="5" data-img="/blockburner/def/defE.png"></div>
      <aside class="panel">
        <div class="tag">“Counter Gaze”</div>
        <p>Defensive - Revert two "medusa" blocks</p>
        <button class="btn" data-target="#block6">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block6" class="block">
    <div class="layout">
      <div class="scene" data-block="6" data-img="/blockburner/def/defRwhite.png"></div>
      <aside class="panel">
        <div class="tag">“Forge Spark”</div>
        <p>Defensive - Convert two blocks to powerups</p>
        <button class="btn" data-target="#block7">Next block ↑</button>
      </aside>
    </div>
  </section>


  <!-- Offensive section title -->
<!-- Offensive Blocks 1-6 -->
  <section id="block7" class="block">
    <div class="layout">
      <div class="scene" data-block="7" data-img="/blockburner/off/offB.png"></div>
      <aside class="panel">
        <div class="tag">“Underpressure”</div>
        <p>Offensive - Add a bottom row</p>
        <button class="btn" data-target="#block8">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block8" class="block">
    <div class="layout">
      <div class="scene" data-block="8" data-img="/blockburner/off/offU.png"></div>
      <aside class="panel">
        <div class="tag">“Shuffle Spark”</div>
        <p>Offensive - Randomly rearranges blocks</p>
        <button class="btn" data-target="#block9">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block9" class="block">
    <div class="layout">
      <div class="scene" data-block="9" data-img="/blockburner/off/offRyellow.png"></div>
      <aside class="panel">
        <div class="tag">“Stone Storm”</div>
        <p>Offensive - Add a few random individual "medusa" blocks to your opponent's grid</p>
        <button class="btn" data-target="#block10">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block10" class="block">
    <div class="layout">
      <div class="scene" data-block="10" data-img="/blockburner/off/offN.png"></div>
      <aside class="panel">
        <div class="tag">“Medusa Spawn”</div>
        <p>Offensive - Spawn a "medusa" block on the opponent's grid</p>
        <button class="btn" data-target="#block11">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block11" class="block">
    <div class="layout">
      <div class="scene" data-block="11" data-img="/blockburner/off/offE.png"></div>
      <aside class="panel">
        <div class="tag">“Disarm”</div>
        <p>Offensive - Remove one power block from an opponent's inventory</p>
        <button class="btn" data-target="#block12">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block12" class="block">
    <div class="layout">
      <div class="scene" data-block="12" data-img="/blockburner/off/offRwhite.png"></div>
      <aside class="panel">
        <div class="tag">“Junk Drop”</div>
        <p>Offensive - Drop a few blocks on your opponent's grid</p>
        <button class="btn" data-target="#block13">Next block ↓</button>
      </aside>
    </div>
  </section>
  <!-- Special Blocks: Midas & Medusa -->
  <section id="block13" class="block">
    <div class="layout">
      <div class="scene" data-block="13" data-img="/blockburner/def/midasblock.png"></div>
      <aside class="panel">
        <div class="tag">“Midas Block”</div>
        <p>Special - Changes nearby blocks into gold “R” blocks, priming huge clears or combos.</p>
        <button class="btn" data-target="#block14">Next block ↓</button>
      </aside>
    </div>
  </section>

  <section id="block14" class="block">
    <div class="layout">
      <div class="scene" data-block="14" data-img="/blockburner/off/medusablock.png"></div>
      <aside class="panel">
        <div class="tag">“Medusa Block”</div>
        <p>Special - Petrifies nearby blocks, turning them into unbreakable Medusa blocks that must be handled strategically.</p>
        <button class="btn" data-target="#story">The Block Burner Story ↓</button>
      </aside>
    </div>
  </section>

  <section id="story" class="block story-block">
  <!-- Parallax background layers -->
  <div class="story-parallax" aria-hidden="true">
    <div class="layer layer-stars"></div>
    <div class="layer layer-stars-2"></div>
    <div class="layer layer-nebula"></div>
    <div class="layer layer-milky"></div>
  </div>

  <!-- Snap-scrolling slides -->
  <div class="story-scroll">
    <article class="story-slide">
      <h2 class="subsection-title">World Background</h2>
      <p>Year 2179.</p>
      <p>
        Earth outsourced survival.<br><br>
        After the Resource Collapse, humanity built a fully automated off-world supply chain: mining drones strip asteroids, harvest moons, tear derelict satellites apart — anything that has mass is converted into standardized freight cubes in orbit.<br><br>
        Those cubes are dropped back to Earth in high-volume “material storms.” It never stops.<br><br>
        The system is run by A.G.N.I. (Autonomous Global Networked Infrastructure), an AI logistics network that decides who gets which materials, when, and how much. A.G.N.I. doesn’t care if humans can keep up. It only cares about throughput quotas.<br><br>
        Cities aren’t cities anymore. They’re landing zones.<br><br>
        The only thing between order and overflow is one job.
      </p>
    </article>

    <article class="story-slide">
      <h2 class="subsection-title">What is a Block Burner?</h2>
      <p>
        You are a Block Burner.<br><br>
        A Block Burner stands in a processing pit at ground level and handles impact loads in real time. Your job is to:<br><br>
        catch incoming resource cubes,<br><br>
        sort them fast,<br><br>
        fuse compatible materials,<br><br>
        clear usable composites,<br><br>
        and push waste back up the line.<br><br>
        If you keep the pit stable and efficient, your sector stays supplied and you get paid.<br><br>
        If you choke the pit and let it jam, pressure builds, the stack breaches containment, and the pit detonates. You’re done. Your district goes dark. You lose.
      </p>
      <p>
        Block Burners are not “employees.” They are “licensed throughput assets.”<br>
        You are not the hero. You are the last human step in an automated supply chain that doesn’t actually need you.<br><br>
        Keep pace.<br>
        Or get replaced.
      </p>
    </article>

    <article class="story-slide">
      <h2 class="subsection-title">You control the grid</h2>
      <p>
        Your grid = your pit.<br><br>
        Each cell is a 1m³ impact cube of raw matter: alloys, fuel slurry, biofiber, toxic slag, weapon scrap, whatever A.G.N.I. rips out of orbit and slams into your zone.<br><br>
        When you connect compatible materials (match / clear lines in the game), that’s you fusing them into usable product. Fused product gets auto-lifted out of the pit by cranes and sent to manufacturing.<br><br>
        When you fail to use the material efficiently — when you leave pieces sitting there — the pit backs up. You’re wasting payload. A.G.N.I. flags you for inefficiency.<br><br>
        Once the pile reaches critical height (top of grid), you are marked “non-viable resource handler.” A.G.N.I. cuts your contract and locks your bay.<br><br>
        Translation: game over.
      </p>
      <p>
        The multiplayer battle is not “friendly competition.” It's industrial warfare.<br><br>
        Two Block Burners are assigned adjacent sectors. You’re both on the same drop schedule. You’re both graded in real time. Only one contract gets renewed.<br><br>
        A.G.N.I. monitors waste output. Any material you fail to convert efficiently is classified as “Residual Load.” Residual Load can be redirected… to someone else’s pit.
      </p>
    </article>

    <article class="story-slide">
      <p>
        When you clear efficiently, you generate waste pressure.<br><br>
        That waste pressure can be vented into your opponent’s pit as junk blocks.<br><br>
        You’re literally dumping industrial overflow into their containment zone to force them to jam first.<br><br>
        A.G.N.I. calls this “competitive load balancing.” Block Burners call it sabotage.
      </p>
      <p>
        <strong>Burner Mode / “BURNER” word effect</strong><br>
        When you trigger the Burner effect (spelling BURNER in-game):<br><br>
        You temporarily override A.G.N.I.’s safety throttles. Over the next few incoming drops, every load you process vents unstable scrap straight into your opponent’s pit. That scrap is not compatible with their existing stack, so it helps you overload your opponent's grid.
      </p>

      <!-- Exit control -->
      <div class="story-controls">
        <button class="btn" data-target="#top">Back to Top ↑</button>
      </div>
    </article>
  </div>
</section>





  <div class="hint">Drag to orbit • Scroll to zoom • Press <kbd>R</kbd> to toggle rotation</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Smooth scroll buttons
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-target]');
      if (!btn) return;
      const sel = btn.getAttribute('data-target');
      const el = document.querySelector(sel);
      if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });

    const sceneEls = Array.from(document.querySelectorAll('.scene'));

    // Shared state across blocks
    const contexts = []; // {renderer, camera, controls, cube, clock, container}
    let spinning = true;
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') spinning = !spinning;
    });

    // Preload unique textures per block based on data-img
    const loader = new THREE.TextureLoader();
    Promise.all(
      sceneEls.map(el => new Promise((res, rej) => {
        const path = el.getAttribute('data-img') || './Bredincanstyle.png';
        loader.load(
          path,
          (tex) => { tex.colorSpace = THREE.SRGBColorSpace; res({ el, tex }); },
          undefined,
          (err) => { console.error('Failed to load', path, err); res({ el, tex: null }); }
        );
      }))
    ).then(items => {
      for (const { el, tex } of items) {
        contexts.push(createScene(el, tex));
      }
      animate();
    });

    function createScene(container, tex) {
      // Renderer per block
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);

      // Scene & Camera
      const scene = new THREE.Scene();
      scene.background = null;

      const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 100);
      camera.position.set(2.4, 1.8, 2.4);

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
      dirLight.position.set(3, 4, 2);
      scene.add(dirLight);

      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // Geometry & Material (use tex if provided; fallback to color)
      const size = 1.2;
      const geometry = new THREE.BoxGeometry(size, size, size);
      let material;
      if (tex) {
        tex.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
        material = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.6, metalness: 0.05 });
      } else {
        material = new THREE.MeshStandardMaterial({ color: 0x446688, roughness: 0.6, metalness: 0.05 });
      }
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      const clock = new THREE.Clock();

      // Resize for this container
      function onResize() {
        const w = container.clientWidth, h = container.clientHeight;
        camera.aspect = w / h; camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }
      const ro = new ResizeObserver(onResize); ro.observe(container);
      window.addEventListener('resize', onResize);

      return { renderer, camera, controls, cube, clock, container, scene };
    }

    function animate() {
      requestAnimationFrame(animate);
      for (const ctx of contexts) {
        const t = ctx.clock.getDelta();
        if (spinning) { ctx.cube.rotation.y += t * 0.6; ctx.cube.rotation.x += t * 0.25; }
        ctx.controls.update();
        ctx.renderer.render(ctx.scene, ctx.camera);
      }
    }
  </script>

  
  
  <script>
    (function() {
      const canvas = document.getElementById('desert-bg');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const DPR = window.devicePixelRatio || 1;

      function size() {
        const cssW = canvas.clientWidth || window.innerWidth;
        const cssH = canvas.clientHeight || window.innerHeight;
        canvas.width  = Math.floor(cssW * DPR);
        canvas.height = Math.floor(cssH * DPR);
        layoutStars();
        draw();
      }

      // Star layers with slight "bloom" glow
      let stars = [];
      function layoutStars() {
        const W = canvas.width, H = canvas.height;
        stars = [];
        const nFar = Math.floor((W * H) / 22000);
        const nNear = Math.floor((W * H) / 55000);
        function mkStar(alphaMin, alphaMax, rMin, rMax, glowMult) {
          return {
            x: Math.random() * W,
            y: Math.random() * H,
            r: Math.random() * (rMax - rMin) + rMin,
            a: alphaMin + Math.random() * (alphaMax - alphaMin),
            g: glowMult * (0.8 + Math.random() * 0.4) // bloom scale
          };
        }
        for (let i = 0; i < nFar; i++) stars.push(mkStar(0.35, 0.7, 0.4, 1.2, 1.8));
        for (let i = 0; i < nNear; i++) stars.push(mkStar(0.55, 1.0, 0.8, 1.8, 2.8));
      }

      function drawSky() {
        const W = canvas.width, H = canvas.height;
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0, '#020713');
        g.addColorStop(0.4, '#07152d');
        g.addColorStop(1, '#02050d');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, W, H);
      }

      function drawStars(time) {
        // Time-based slight twinkle
        const t = (time || 0) * 0.001;
        ctx.save();
        for (const s of stars) {
          // subtle twinkle factor
          const tw = 0.85 + 0.15 * Math.sin((s.x * 0.0007 + s.y * 0.0004) + t * 1.2);
          const baseA = s.a * tw;

          // bloom/glow using radial gradient
          const glowR = s.r * (2.5 * s.g);
          const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, glowR);
          grad.addColorStop(0.0, 'rgba(255,255,255,' + Math.min(0.22 * baseA, 0.22) + ')');
          grad.addColorStop(0.5, 'rgba(180,200,255,' + Math.min(0.10 * baseA, 0.10) + ')');
          grad.addColorStop(1.0, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(s.x, s.y, glowR, 0, Math.PI * 2); ctx.fill();

          // star core
          ctx.globalAlpha = Math.min(1, baseA);
          ctx.fillStyle = '#ffffff';
          ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
          ctx.globalAlpha = 1;
        }
        ctx.restore();
      }

      let rafId = null;
      function draw(time=0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawSky();
        drawStars(time);
        rafId = requestAnimationFrame(draw);
      }

      window.addEventListener('resize', size, { passive: true });
      size();
      if (!rafId) rafId = requestAnimationFrame(draw);
    })();
  </script>
<script>
(function () {
  
  const slides   = [...document.querySelectorAll('#story .story-slide')];
  const layers   = {
    stars:  document.querySelector('#story .layer-stars'),
    stars2: document.querySelector('#story .layer-stars-2'),
    nebula: document.querySelector('#story .layer-nebula'),
    milky:  document.querySelector('#story .layer-milky'),
  };

  /* Reveal slides when they enter the viewport of the scroll container */
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(e => e.target.classList.toggle('is-visible', e.isIntersecting));
  }, { root: scrollEl, threshold: 0.25 });
  slides.forEach(s => io.observe(s));

  /* Parallax: offset layers at different rates based on scroll progress */
  function onScroll() {
    const max = scrollEl.scrollHeight - scrollEl.clientHeight;
    const p = max > 0 ? scrollEl.scrollTop / max : 0; // 0..1

    // Move layers subtly at different depths
    const translate = (y) => `translate3d(0, ${y}px, 0)`;
    if (layers.stars)  layers.stars.style.transform  = translate(p * -40);  // far
    if (layers.stars2) layers.stars2.style.transform = translate(p * -80);
    if (layers.nebula) layers.nebula.style.transform = translate(p * -140);
    if (layers.milky)  layers.milky.style.transform  = translate(p * -220); // closest
  }
  scrollEl.addEventListener('scroll', onScroll, { passive: true });
  onScroll();

  /* Keep your existing smooth anchor scroll behavior working */
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-target]');
    if (!btn) return;
    const id = btn.getAttribute('data-target');
    const el = document.querySelector(id);
    if (!el) return;
    const scroller = el.closest('.story-scroll') || document.scrollingElement;
    // If target is inside a snap container, scroll within it; else fallback
    if (scroller && scroller !== document.scrollingElement) {
      const slide = el.closest('.story-slide') || el;
      scroller.scrollTo({ top: slide.offsetTop, behavior: 'smooth' });
    } else {
      el.scrollIntoView({ behavior: 'smooth' });
    }
  });
})();
</script>


</body>
</html>
